<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml">

    <head>
        <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
        <title>Babylon Template</title>

        <style>
            html, body {
                overflow: hidden;
                width: 100%;
                height: 100%;
                margin: 0;
                padding: 0;
            }

            #renderCanvas {
                width: 100%;
                height: 100%;
                touch-action: none;
            }
        </style>

        <script src="https://cdn.babylonjs.com/babylon.js"></script>
        <script src="https://cdn.babylonjs.com/loaders/babylonjs.loaders.min.js"></script>
        <script src="https://code.jquery.com/pep/0.4.3/pep.js"></script>
    </head>

   <body>
    
    <canvas id="renderCanvas" touch-action="none"></canvas> <!-- touch-action="none" for best results from PEP -->

    <script>

        /*================================================= UTIL CODE ==============================================*/

        /* Appends source contents to the end of target contents (in place!) */
        function flush_array(target, source) {
            for (let i = 0; i < source.length; ++i) {
                target.push(source[i]);
            }
            return target;
        }

        /* Replicates array a few times */
        function replicate_array(source, repeat) {
            let target = [];
            while (repeat !== 0) {
                flush_array(target, source);
                repeat--;
            }
            return target;
        }

        /* Utils for 2D UV manipulation */
        class Math2dForUV {};

        Math2dForUV.TOP_LEFT = "tl";
        Math2dForUV.TOP_RIGHT = "tr";
        Math2dForUV.BOTTOM_LEFT = "bl";
        Math2dForUV.BOTTOM_RIGHT = "br";

        /* normalize_coords is: TOP_LEFT, TOP_RIGHT, BOTTOM_RIGHT, BOTTOM_LEFT */
        Math2dForUV.selectUV = function(selectors, normalizedCoords) {

            let results = [];

            for (let sel of selectors) {
                if (sel === Math2dForUV.TOP_LEFT) {
                    results.push(normalizedCoords[0]);
                    results.push(normalizedCoords[1]);
                }
                if (sel === Math2dForUV.TOP_RIGHT) {
                    results.push(normalizedCoords[2]);
                    results.push(normalizedCoords[3]);
                }
                if (sel === Math2dForUV.BOTTOM_RIGHT) {
                    results.push(normalizedCoords[4]);
                    results.push(normalizedCoords[5]);
                }
                if (sel === Math2dForUV.BOTTOM_LEFT) {
                    results.push(normalizedCoords[6]);
                    results.push(normalizedCoords[7]);
                }
            }
                        
            return results;
        }

        /* Adds added array to a source, iterating over added array as a loop (in place!) */
        function cyclic_add_array(source, added) {
            for (let i = 0; i < source.length; ++i) {
                let ai = i % added.length;
                source[i] += added[ai];
            }
            return source;
        }
    
        /* More than just Math class */
        class BeyondMath {};

        /* Returns one with "one" probability, otherwise returns zero */
        BeyondMath.indicatorRandom = function (one) {
            if (Math.random() < one) return 1;
            return 0;
        }

        /*================================================= ENGINE-FREE CLASSES ==============================================*/

        
        class BlockUvMap {
            
            /* l r u d f b */
            project(idBlock, side) {

                if (idBlock === 3) {
                    
                    if (side === 'u') {
                        return [0.5, 0, 1, 0, 1, 0.5, 0.5, 0.5];    // grass
                    }

                    if (side === 'd') {
                        return [0.5, 0.5, 1, 0.5, 1, 1, 0.5, 1];    // dirt
                    }

                    return [0, 0.5, 0.5, 0.5, 0.5, 1, 0, 1];    // dirt grass
                }

                if (idBlock === 2) {
                    return [0.5, 0.5, 1, 0.5, 1, 1, 0.5, 1];  // dirt
                }

                if (idBlock === 1) {
                    return [0, 0, 0.5, 0, 0.5, 0.5, 0, 0.5]; // stone
                }

                return [0, 0, 1, 0, 1, 1, 0, 1];    // default - all atlas
            }
        }

        /* Represents a class for making custom terrain from squares */
        class SquareGridBuilder {
            
            constructor() {
                this.positions =  [];
                this.indices = [];
                this.uvs = [];
                this.normals = [];
                this.uvMap = new BlockUvMap();
                
                
                this.straightIndices = [0, 2, 1, 1, 2, 3];
                this.reverseIndices = [1, 2, 0, 3, 2, 1]; // just like straight, but the alternative side
            }

            insertPiece(new_positions, new_indices, new_uvs, new_normals) {
                flush_array(this.positions, new_positions);
                flush_array(this.indices, new_indices);
                flush_array(this.uvs, new_uvs);
                flush_array(this.normals, new_normals);
            }
            
            insertSquareGridBuilder(otherSgb) {
                
                let all_indices = this.positions.length / 3;
                
                flush_array(this.positions, otherSgb.positions);
                flush_array(this.indices, cyclic_add_array([...otherSgb.indices], [all_indices]));
                flush_array(this.uvs, otherSgb.uvs);
                flush_array(this.normals, otherSgb.normals);
            }

            insertSide(xyz, vertex_loop, index_loop, normal_sample, uvs) {
                
                let all_indices = this.positions.length / 3;
                
                this.insertPiece(
                    cyclic_add_array(vertex_loop, xyz)
                    , cyclic_add_array(index_loop, [all_indices])                    
                    , uvs
                    , replicate_array(normal_sample, 4)
                );
            }

            insertLeft(x, y, z, idBlock) {
                
                this.insertSide(
                    [x, y, z]
                    , [0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 1, 1]
                    , [...this.straightIndices]
                    , [-1, 0, 0]
                    , Math2dForUV.selectUV(["tr", "tl", "br", "bl"], this.uvMap.project(idBlock, "l"))
                );
            }

            insertRight(x, y, z, idBlock) {
                
                this.insertSide(
                    [x + 1, y, z]
                    , [0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 1, 1]
                    , [...this.reverseIndices]
                    , [1, 0, 0]
                    , Math2dForUV.selectUV(["tl", "tr", "bl", "br"], this.uvMap.project(idBlock, "r"))
                );
            }

            insertBack(x, y, z, idBlock) {
                
                this.insertSide(
                    [x, y, z]
                    , [0, 0, 0, 0, 1, 0, 1, 0, 0, 1, 1, 0]
                    , [...this.straightIndices]
                    , [0, 0, -1]
                    , Math2dForUV.selectUV(["tl", "bl", "tr", "br"], this.uvMap.project(idBlock, "b"))
                );
            }

            insertFront(x, y, z, idBlock) {
                
                this.insertSide(
                    [x, y, z + 1]
                    , [0, 0, 0, 0, 1, 0, 1, 0, 0, 1, 1, 0]
                    , [...this.reverseIndices]
                    , [0, 0, 1]
                    //, [1, 0, 1, 1, 0, 0, 0, 1]
                    , Math2dForUV.selectUV(["tr", "br", "tl", "bl"], this.uvMap.project(idBlock, "f"))
                );
            }

            insertTop(x, y, z, idBlock) {
                
                this.insertSide(
                    [x, y + 1, z]
                    , [0, 0, 0, 0, 0, 1, 1, 0, 0, 1, 0, 1]
                    , [...this.straightIndices]
                    , [0, 1, 0]
                    , Math2dForUV.selectUV(["tl", "bl", "tr", "br"], this.uvMap.project(idBlock, "u"))
                );
            }

            insertBottom(x, y, z, idBlock) {
                
                this.insertSide(
                    [x, y, z]
                    , [0, 0, 0, 0, 0, 1, 1, 0, 0, 1, 0, 1]
                    , [...this.reverseIndices]
                    , [0, -1, 0]
                    , Math2dForUV.selectUV(["tr", "br", "tl", "bl"], this.uvMap.project(idBlock, "d"))
                );
            }
        }

        class Array3D {
            
            constructor(sx, sy, sz) {
                this.sx = sx;
                this.sy = sy;
                this.sz = sz;
                this.data = [];
            }

            hasCoords(x, y, z) {
                return (x >= 0 && x < this.sx) && (y >= 0 && y < this.sy) && (z >= 0 && z < this.sz);
            }

            toLinear(x, y, z) {
                return z + this.sz * (y + x * this.sy);
            }

            setValue(x, y, z, value) {
                this.data[this.toLinear(x, y, z)] = value;
            }

            getValue(x, y, z) {
                return this.data[this.toLinear(x, y, z)];
            }

            getValueEx(x, y, z, otherwise) {
                if (!this.hasCoords(x, y, z))
                    return otherwise;
                return this.data[this.toLinear(x, y, z)];
            }

            iterate(iter) {
                for (let i = 0; i < this.sx; ++i) {
                    for (let j = 0; j < this.sy; ++j) {
                        for (let k = 0; k < this.sz; ++k) {
                            let new_val = iter(i, j, k, this.getValue(i, j, k));
                            if (new_val !== undefined)
                                this.setValue(i, j, k, new_val);
                        }
                    }
                }
            }
            
        }

        const CHUNK_SIZE = 16;

        /* Represents a single terrain chunk 16 * 16 * 16 size */
        class TerrainChunk {
            
            /* init chunks own coodrs */
            constructor(cx, cy, cz) {
                this.cx = cx;
                this.cy = cy;
                this.cz = cz;
                this.chunkData = new Array3D(CHUNK_SIZE, CHUNK_SIZE, CHUNK_SIZE);   // TODO: make loadable

                this.reset();
            }
            
            reset() {
                this.localSgb = null;
            }

            /*
                TODO: proper UVs
            */
            drawToSGB(sgb, leftNgh, rightNgh, topNgh, bottomNgh, frontNgh, backNgh) {
                
                if (this.localSgb !== null) {
                    sgb.insertSquareGridBuilder(this.localSgb);
                    return;
                }

                this.localSgb = new SquareGridBuilder();

                let localSgb = this.localSgb;

                let offsetX = CHUNK_SIZE * this.cx;
                let offsetY = CHUNK_SIZE * this.cy;
                let offsetZ = CHUNK_SIZE * this.cz;

                let chunkData = this.chunkData;                
                chunkData.iterate(
                    (i, j, k, idBlock) => {

                        let airBlockCode = 0;

                        if (idBlock !== airBlockCode) {
                            
                            /* TODO: replace === airBlockCode with a newly created isTransparent() function */
                            if (chunkData.getValueEx(i - 1, j, k, TerrainChunk.testForValueAt(leftNgh, CHUNK_SIZE - 1, j, k, airBlockCode)) === airBlockCode)
                                localSgb.insertLeft(i + offsetX, j + offsetY, k + offsetZ, idBlock);
                            
                            if (chunkData.getValueEx(i + 1, j, k, TerrainChunk.testForValueAt(rightNgh, 0, j, k, airBlockCode)) === airBlockCode)
                                localSgb.insertRight(i + offsetX, j + offsetY, k + offsetZ, idBlock);
                            
                            if (chunkData.getValueEx(i, j + 1, k, TerrainChunk.testForValueAt(topNgh, i, 0, k, airBlockCode)) === airBlockCode)
                                localSgb.insertTop(i + offsetX, j + offsetY, k + offsetZ, idBlock);
                            
                            if (chunkData.getValueEx(i, j - 1, k, TerrainChunk.testForValueAt(bottomNgh, i, CHUNK_SIZE - 1, k, airBlockCode)) === airBlockCode)
                                localSgb.insertBottom(i + offsetX, j + offsetY, k + offsetZ, idBlock);
                            
                            if (chunkData.getValueEx(i, j, k + 1, TerrainChunk.testForValueAt(frontNgh, i, j, 0, airBlockCode)) === airBlockCode)
                                localSgb.insertFront(i + offsetX, j + offsetY, k + offsetZ, idBlock);
                            
                            if (chunkData.getValueEx(i, j, k - 1, TerrainChunk.testForValueAt(backNgh, i, j, CHUNK_SIZE - 1, airBlockCode)) === airBlockCode)
                                localSgb.insertBack(i + offsetX, j + offsetY, k + offsetZ, idBlock);
                            
                        }
                    }
                );
                
                sgb.insertSquareGridBuilder(this.localSgb);
            }
        }

        TerrainChunk.testForValueAt = function (tc, x, y, z, otherwise) {
            if (tc === null || tc === undefined)
                return otherwise;            
            return tc.chunkData.getValueEx(x, y, z, otherwise);
        }

        /* Class responsible for loading chunks from particular coords */
        class TerrainChunkProvider {
            
            constructor() {}

            obtainChunkFrom(cx, cy, cz) {

                let chunk = new TerrainChunk(cx, cy, cz);

                chunk.chunkData.iterate(
                    (x, y, z, value) => {

                        //f ((cx ^ cy ^ cz) % 8 !== 0) return 0;

                        //return 1;

                        if (cy > 2) {
                            return 0;
                        }

                        let idBlock = 1;
                        if (cy > 1)
                            idBlock = 2;

                        if (cy === 2 && y === CHUNK_SIZE - 1) {
                            idBlock = 3;
                        }

                        if (cy !== 2)
                            return idBlock;
                        
                        if (x === 0 && y === 0) return idBlock;
                        if (y === 0 && z === 0) return idBlock;
                        if (x === 0 && z === 0) return idBlock;
                        
                        if (x === 15 && y === 0) return idBlock;
                        if (y === 15 && z === 0) return idBlock;
                        if (x === 15 && z === 0) return idBlock;
                        
                        if (x === 15 && y === 15) return idBlock;
                        if (y === 15 && z === 15) return idBlock;
                        if (x === 15 && z === 15) return idBlock;
                        
                        if (x === 0 && y === 15) return idBlock;
                        if (y === 0 && z === 15) return idBlock;
                        if (x === 0 && z === 15) return idBlock;

                        if (x >= 4 && x < 12 && y >= 4 && y < 12 && z >= 4 && z < 12)
                            return BeyondMath.indicatorRandom(0.05) === 1 ? 2 : 0;

                        return 0;
                    }
                );
                
                return chunk;
            }
        }

        const CHUNKS_VISIBLE_RADIUS = 3;
        const CHUNKS_VISIBLE_RADIUS_FAR = 6;

        /* Class responsible for chuck loading and unloading, and their cumulative rendering with the neighbour consideration */
        class TerrainGrid {
            
            constructor(renderer) {
                this.chunkMap = new Object();
                this.changed = false;
                this.renderer = renderer;
            }

            dropChunk(x, y, z) {

                let cm = this.chunkMap;
                let droppedChunk = cm[[x, y, z]];

                delete cm[[x, y, z]];

                if (droppedChunk !== null && droppedChunk !== undefined)
                    this.updateChunkNeighboursAt(x, y, z);

                this.renderer.deleteChunk(x, y, z);
            }

            getChunk(x, y, z) {
                let cm = this.chunkMap;
                return cm[[x, y, z]];
            }

            hasChunk(x, y, z) {
                let gc = this.getChunk(x, y, z);
                return !(gc === undefined || gc === null); // TODO: check this - can I use just "!!gc" ?
            }

            updateChunkAt(x, y, z) {
                let cn = this.getChunk(x, y, z);

                if (cn !== null && cn !== undefined) {
                    cn.reset();
    
                    let cn_sgb = new SquareGridBuilder();
                        
                    cn.drawToSGB(
                        cn_sgb
                        , this.getChunk(x - 1, y, z)
                        , this.getChunk(x + 1, y, z)
                        , this.getChunk(x, y + 1, z)
                        , this.getChunk(x, y - 1, z)
                        , this.getChunk(x, y, z + 1)
                        , this.getChunk(x, y, z - 1)                        
                    );

                    this.renderer.updateChunk(x, y, z, cn_sgb);
                }
            }

            updateChunkNeighboursAt(x, y, z) {

                this.updateChunkAt(x - 1, y, z);
                this.updateChunkAt(x + 1, y, z);
                this.updateChunkAt(x, y - 1, z);
                this.updateChunkAt(x, y + 1, z);
                this.updateChunkAt(x, y, z - 1);
                this.updateChunkAt(x, y, z + 1);

                this.changed = true;
            }
            
            uploadChunk(chunk) {
                //console.log("TERRAIN: upload " + [chunk.cx, chunk.cy, chunk.cz]);
                
                let cm = this.chunkMap;
                chunk.reset();
                cm[[chunk.cx, chunk.cy, chunk.cz]] = chunk;

                this.updateChunkNeighboursAt(chunk.cx, chunk.cy, chunk.cz);
                this.updateChunkAt(chunk.cx, chunk.cy, chunk.cz);
            }

        }

        /* TODO: I need a class that would manually construct TerrainGrid of chunks and update new chunks in it as the new data approaches */
        class TerrainGridManipulator {

            constructor(terrain, chunkProvider) {
                this.terrain = terrain;
                this.chunkProvider = chunkProvider;

                this.pengingAsyncTasks = new Object();
            }
            
            generate() {
                let terrain = this.terrain;
                let chunkProvider = this.chunkProvider;
            }

            isPendingForDeletion(x, y, z) {
                
            }

            isPendingForUploading(x, y, z) {
                
            }

            askAsyncUploadAt(x, y, z) {

                let that = this;

                if (!that.terrain.hasChunk(x, y, z)) {
                    
                    
                    setTimeout(() => {
                        if (!that.terrain.hasChunk(x, y, z)) {
                            let tc = that.chunkProvider.obtainChunkFrom(x, y, z);
                            that.terrain.uploadChunk(tc);
                        }
                    }, 0);
                    
                    this.pengingAsyncTasks[[x, y, z]] = [x, y, z, 1];

                    this.kickstartAsyncChain();
                }
            }

            askAsyncDeleteAt(x, y, z) {

                let terr = this.terrain;

                
                setTimeout(() => {
                    terr.dropChunk(x, y, z);
                }, 0);

                this.pengingAsyncTasks[[x, y, z]] = [x, y, z, 0];

                this.kickstartAsyncChain();
            }

            processAsyncChain() {
                
            }

            kickstartAsyncChain() {
                
            }

            reloadRequiredTerrainParts(characterPosition) {
                
                let cx = Math.floor(characterPosition[0] / CHUNK_SIZE);
                let cy = Math.floor(characterPosition[1] / CHUNK_SIZE);
                let cz = Math.floor(characterPosition[2] / CHUNK_SIZE);

                if (this.cx === cx && this.cy === cy && this.cz === cz)
                    return;

                this.cx = cx;
                this.cy = cy;
                this.cz = cz;

                /* Delete if too far away */
                for (const [key, value] of Object.entries(this.terrain.chunkMap)) {
                    let terr = this.terrain;
                            
                    if (Math.max(Math.abs(value.cx - cx), Math.abs(value.cy - cy), Math.abs(value.cz - cz)) > CHUNKS_VISIBLE_RADIUS_FAR) {
                        this.askAsyncDeleteAt(value.cx, value.cy, value.cz);
                    }
                }

                /* Upload if too close */
                for (let i = -CHUNKS_VISIBLE_RADIUS + cx; i < CHUNKS_VISIBLE_RADIUS + cx; ++i) {
                    for (let j = -CHUNKS_VISIBLE_RADIUS + cy; j < CHUNKS_VISIBLE_RADIUS + cy; ++j) {
                        for (let k = -CHUNKS_VISIBLE_RADIUS + cz; k < CHUNKS_VISIBLE_RADIUS + cz; ++k) {
                            this.askAsyncUploadAt(i, j, k);
                        }
                    }
                }
                
                /*
                if (Math.random() < 1) {
                    let i = Math.floor(Math.random() * 16) - 8;
                    let j = Math.floor(Math.random() * 8) - 4;
                    let k = Math.floor(Math.random() * 16) - 8;

                    if (Math.random() < 0.5) {                    
                        let tc = this.chunkProvider.obtainChunkFrom(i, j, k);
                        this.terrain.uploadChunk(tc);                    
                    }
                    else
                        this.terrain.dropChunk(i, j, k);
                }
                */
                
                
            }

        };

        /* ========================= ENGINE-DEPENDENT CLASSES =============================================================== */

        /* TODO: make it disposable */
        class TerrainRendererForBabylon {

            constructor(scene, material) {
                this.scene = scene;
                this.material = material;
                this.lookupMeshes = new Object();
            }

            deleteChunk(x, y, z) {
                //console.log("RENDER: drop " + [x, y, z]);
                
                let mesh = this.lookupMeshes[[x, y, z]];

                if (mesh !== null && mesh !== undefined) {
                    mesh.dispose();
                    delete this.lookupMeshes[[x, y, z]];
                }
            }

            updateChunk(x, y, z, sgb) {
                //onsole.log("RENDER: update " + [x, y, z]);

                if (sgb.positions.length === 0) {
                    this.deleteChunk(x, y, z);
                    return;
                }

                let scene = this.scene;

                var customMesh = this.lookupMeshes[[x, y, z]];

                if (customMesh === null || customMesh === undefined) customMesh = new BABYLON.Mesh("custom", scene);
                
                var vertexData = new BABYLON.VertexData();
                
                vertexData.positions = sgb.positions;
                vertexData.indices = sgb.indices;
                vertexData.normals = sgb.normals;
                vertexData.uvs = sgb.uvs;

                vertexData.applyToMesh(customMesh);

                customMesh.material = this.material;

                this.lookupMeshes[[x, y, z]] = customMesh;

            }

        };



        /* ========================= UNPROCESSED CODE ===================================================================== */


        const canvas = document.getElementById("renderCanvas"); // Get the canvas element
        const engine = new BABYLON.Engine(canvas, true); // Generate the BABYLON 3D engine

        let myCustomMesh;

        let myMaterial;

        let myCamera;

        // Add your code here matching the playground format
        const createScene = function () {
    
            const scene = new BABYLON.Scene(engine);
            scene.clearColor = new BABYLON.Color3(0.3, 0.3, 0.6);

            //const camera = new BABYLON.ArcRotateCamera("camera", -Math.PI / 2, Math.PI / 2.5, 15, new BABYLON.Vector3(0, 0, 0));
            const camera = new BABYLON.UniversalCamera("UniversalCamera", new BABYLON.Vector3(0, -5, -10), scene);

            camera.attachControl(canvas, true);
            camera.position.y = 50;
            //camera.setTarget(new BABYLON.Vector3(0, 0, 0));

            myCamera = camera;
            
            const light = new BABYLON.HemisphericLight("light", new BABYLON.Vector3(1, 1, 0));

            //-------------------------------------------------------------------------------------

            const groundMat2 = new BABYLON.StandardMaterial("groundMat");
            groundMat2.diffuseColor = new BABYLON.Color3(0, 1, 0);

            var img = new Image(512, 512);
            img.src = 'images/trava.png';
            
            const boxMat2 = new BABYLON.StandardMaterial("boxMat");
            //boxMat2.diffuseTexture = new BABYLON.Texture("https://www.babylonjs-playground.com/textures/floor.png");
            
            //boxMat2.diffuseTexture = new BABYLON.Texture("https://i.postimg.cc/3w7Ld88p/trava.png");
            //boxMat2.diffuseTexture = new BABYLON.Texture("https://i.postimg.cc/2SvXw1Dq/trava-orient.png");

            let myTextr = new BABYLON.Texture("https://i.postimg.cc/657Ljb8m/atlas.png", scene, false, undefined);
            
            
            //myTextr.updateSamplingMode(BABYLON.Texture.NEAREST_SAMPLINGMODE);
            myTextr.wrapR = BABYLON.CLAMP_ADDRESSMODE;

            
            myTextr.anisotropicFilteringLevel = 1;
            myTextr.homogeneousRotationInUVTransform = true;

            boxMat2.diffuseTexture = myTextr;

            //--------------------------------------------------------------------------------------

            myMaterial = boxMat2;
            
            //var customMesh = new BABYLON.Mesh("custom", scene);

            //myCustomMesh = customMesh;

            //customMesh.material = boxMat2;

            //-------------------------------------------------------------------------------------

            return scene;
        };

        const scene = createScene(); //Call the createScene function

        
        

        let terrainRenderBabylon = new TerrainRendererForBabylon(scene, myMaterial);

        let terrain = new TerrainGrid(terrainRenderBabylon);

        let chunkProvider = new TerrainChunkProvider();

        let terrainManip = new TerrainGridManipulator(terrain, chunkProvider);
        terrainManip.generate();


        

        // Register a render loop to repeatedly render the scene
        engine.runRenderLoop(function () {
            
            terrainManip.reloadRequiredTerrainParts([myCamera.position.x, myCamera.position.y, myCamera.position.z]);

            scene.render();
        });

        // Watch for browser/canvas resize events
        window.addEventListener("resize", function () {
                engine.resize();
        });
    </script>

   </body>

</html>
