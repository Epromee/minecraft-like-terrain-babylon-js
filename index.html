<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml">

    <head>
        <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
        <title>Babylon Template</title>

        <style>
            html, body {
                overflow: hidden;
                width: 100%;
                height: 100%;
                margin: 0;
                padding: 0;
            }

            #renderCanvas {
                width: 100%;
                height: 100%;
                touch-action: none;
            }
        </style>

        <script src="https://cdn.babylonjs.com/babylon.js"></script>
        <script src="https://cdn.babylonjs.com/loaders/babylonjs.loaders.min.js"></script>
        <script src="https://code.jquery.com/pep/0.4.3/pep.js"></script>
    </head>

   <body>
    
    <canvas id="renderCanvas" touch-action="none"></canvas> <!-- touch-action="none" for best results from PEP -->

    <script>

        /*================================================= UTIL CODE ==============================================*/

        /* Appends source contents to the end of target contents (in place!) */
        function flush_array(target, source) {
            for (let i = 0; i < source.length; ++i) {
                target.push(source[i]);
            }
            return target;
        }

        /* Replicates array a few times */
        function replicate_array(source, repeat) {
            let target = [];
            while (repeat !== 0) {
                flush_array(target, source);
                repeat--;
            }
            return target;
        }

        /* Adds added array to a source, iterating over added array as a loop (in place!) */
        function cyclic_add_array(source, added) {
            for (let i = 0; i < source.length; ++i) {
                let ai = i % added.length;
                source[i] += added[ai];
            }
            return source;
        }
    
        /* More than just Math class */
        class BeyondMath {};

        /* Returns one with "one" probability, otherwise returns zero */
        BeyondMath.indicatorRandom = function (one) {
            if (Math.random() < one) return 1;
            return 0;
        }

        /*================================================= GAME CODE ==============================================*/

        /* Represents a class for making custom terrain from squares */
        class SquareGridBuilder {
            
            constructor() {
                this.positions =  [];
                this.indices = [];
                this.uvs = [];
                this.normals = [];
                
                this.selected_uv = [0, 0, 0, 1, 1, 0, 1, 1];
                this.straightIndices = [0, 2, 1, 1, 2, 3];
                this.reverseIndices = [1, 2, 0, 3, 2, 1]; // just like straight, but the alternative side
            }

            insertPiece(new_positions, new_indices, new_uvs, new_normals) {
                flush_array(this.positions, new_positions);
                flush_array(this.indices, new_indices);
                flush_array(this.uvs, new_uvs);
                flush_array(this.normals, new_normals);
            }
            
            insertSquareGridBuilder(otherSgb) {
                
                let all_indices = this.positions.length / 3;
                
                flush_array(this.positions, otherSgb.positions);
                flush_array(this.indices, cyclic_add_array([...otherSgb.indices], [all_indices]));
                flush_array(this.uvs, otherSgb.uvs);
                flush_array(this.normals, otherSgb.normals);
            }

            insertSide(xyz, vertex_loop, index_loop, normal_sample) {
                
                let all_indices = this.positions.length / 3;
                
                this.insertPiece(
                    cyclic_add_array(vertex_loop, xyz)
                    , cyclic_add_array(index_loop, [all_indices])                    
                    , this.selected_uv
                    , replicate_array(normal_sample, 4)
                );
            }

            insertLeft(x, y, z) {
                
                this.insertSide(
                    [x, y, z]
                    , [0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 1, 1]
                    , [...this.straightIndices]
                    , [-1, 0, 0]
                );
            }

            insertRight(x, y, z) {
                
                this.insertSide(
                    [x + 1, y, z]
                    , [0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 1, 1]
                    , [...this.reverseIndices]
                    , [1, 0, 0]
                );
            }

            insertBack(x, y, z) {
                
                this.insertSide(
                    [x, y, z]
                    , [0, 0, 0, 0, 1, 0, 1, 0, 0, 1, 1, 0]
                    , [...this.straightIndices]
                    , [0, 0, -1]
                );
            }

            insertFront(x, y, z) {
                
                this.insertSide(
                    [x, y, z + 1]
                    , [0, 0, 0, 0, 1, 0, 1, 0, 0, 1, 1, 0]
                    , [...this.reverseIndices]
                    , [0, 0, 1]
                );
            }

            insertTop(x, y, z) {
                
                this.insertSide(
                    [x, y + 1, z]
                    , [0, 0, 0, 0, 0, 1, 1, 0, 0, 1, 0, 1]
                    , [...this.straightIndices]
                    , [0, 1, 0]
                );
            }

            insertBottom(x, y, z) {
                
                this.insertSide(
                    [x, y, z]
                    , [0, 0, 0, 0, 0, 1, 1, 0, 0, 1, 0, 1]
                    , [...this.reverseIndices]
                    , [0, -1, 0]
                );
            }
        }

        class Array3D {
            
            constructor(sx, sy, sz) {
                this.sx = sx;
                this.sy = sy;
                this.sz = sz;
                this.data = [];
            }

            hasCoords(x, y, z) {
                return (x >= 0 && x < this.sx) && (y >= 0 && y < this.sy) && (z >= 0 && z < this.sz);
            }

            toLinear(x, y, z) {
                return z + this.sz * (y + x * this.sy);
            }

            setValue(x, y, z, value) {
                this.data[this.toLinear(x, y, z)] = value;
            }

            getValue(x, y, z) {
                return this.data[this.toLinear(x, y, z)];
            }

            getValueEx(x, y, z, otherwise) {
                if (!this.hasCoords(x, y, z))
                    return otherwise;
                return this.data[this.toLinear(x, y, z)];
            }

            iterate(iter) {
                for (let i = 0; i < this.sx; ++i) {
                    for (let j = 0; j < this.sy; ++j) {
                        for (let k = 0; k < this.sz; ++k) {
                            let new_val = iter(i, j, k, this.getValue(i, j, k));
                            if (new_val !== undefined)
                                this.setValue(i, j, k, new_val);
                        }
                    }
                }
            }
            
        }

        const CHUNK_SIZE = 16;

        /* Represents a single terrain chunk 16 * 16 * 16 size */
        class TerrainChunk {

            /*
                TODO:
                1) Optimize for non-rendering the redundant blocks (like, all air or all ground)
            */
            
            /* init chunks own coodrs */
            constructor(cx, cy, cz) {
                this.cx = cx;
                this.cy = cy;
                this.cz = cz;
                this.chunkData = new Array3D(CHUNK_SIZE, CHUNK_SIZE, CHUNK_SIZE);

                this.reset();
            }

            reset() {
                this.localSgb = null;
            }

            /*
                TODO: proper UVs
            */
            drawToSGB(sgb, leftNgh, rightNgh, topNgh, bottomNgh, frontNgh, backNgh) {
                
                if (this.localSgb !== null) {
                    sgb.insertSquareGridBuilder(this.localSgb);
                }

                this.localSgb = new SquareGridBuilder();

                let localSgb = this.localSgb;

                let offsetX = CHUNK_SIZE * this.cx;
                let offsetY = CHUNK_SIZE * this.cy;
                let offsetZ = CHUNK_SIZE * this.cz;

                let chunkData = this.chunkData;                
                chunkData.iterate(
                    (i, j, k, value) => {

                        let airBlockCode = 0;

                        if (value !== airBlockCode) {
                            
                            if (chunkData.getValueEx(i - 1, j, k, TerrainChunk.testForValueAt(leftNgh, CHUNK_SIZE - 1, j, k, airBlockCode)) === airBlockCode)
                                localSgb.insertLeft(i + offsetX, j + offsetY, k + offsetZ);
                            
                            if (chunkData.getValueEx(i + 1, j, k, TerrainChunk.testForValueAt(rightNgh, 0, j, k, airBlockCode)) === airBlockCode)
                                localSgb.insertRight(i + offsetX, j + offsetY, k + offsetZ);
                            
                            if (chunkData.getValueEx(i, j + 1, k, TerrainChunk.testForValueAt(topNgh, i, 0, k, airBlockCode)) === airBlockCode)
                                localSgb.insertTop(i + offsetX, j + offsetY, k + offsetZ);
                            
                            if (chunkData.getValueEx(i, j - 1, k, TerrainChunk.testForValueAt(bottomNgh, i, CHUNK_SIZE - 1, k, airBlockCode)) === airBlockCode)
                                localSgb.insertBottom(i + offsetX, j + offsetY, k + offsetZ);
                            
                            if (chunkData.getValueEx(i, j, k + 1, TerrainChunk.testForValueAt(frontNgh, i, j, 0, airBlockCode)) === airBlockCode)
                                localSgb.insertFront(i + offsetX, j + offsetY, k + offsetZ);
                            
                            if (chunkData.getValueEx(i, j, k - 1, TerrainChunk.testForValueAt(backNgh, i, j, CHUNK_SIZE - 1, airBlockCode)) === airBlockCode)
                                localSgb.insertBack(i + offsetX, j + offsetY, k + offsetZ);
                            
                        }
                    }
                );
                
                sgb.insertSquareGridBuilder(this.localSgb);
            }
        }

        TerrainChunk.testForValueAt = function (tc, x, y, z, otherwise) {
            if (tc === null || tc === undefined)
                return otherwise;            
            return tc.chunkData.getValueEx(x, y, z, otherwise);
        }

        /* Class responsible for loading chunks from particular coords */
        class TerrainChunkProvider {
            
            constructor() {}

            obtainChunkFrom(cx, cy, cz) {

                let chunk = new TerrainChunk(cx, cy, cz);

                chunk.chunkData.iterate(
                    (x, y, z, value) => {

                        if ((cx ^ cy ^ cz) % 8 !== 0) return 0;
                        
                        if (x === 0 && y === 0) return 1;
                        if (y === 0 && z === 0) return 1;
                        if (x === 0 && z === 0) return 1;
                        
                        if (x === 15 && y === 0) return 1;
                        if (y === 15 && z === 0) return 1;
                        if (x === 15 && z === 0) return 1;
                        
                        if (x === 15 && y === 15) return 1;
                        if (y === 15 && z === 15) return 1;
                        if (x === 15 && z === 15) return 1;
                        
                        if (x === 0 && y === 15) return 1;
                        if (y === 0 && z === 15) return 1;
                        if (x === 0 && z === 15) return 1;

                        if (x >= 4 && x < 12 && y >= 4 && y < 12 && z >= 4 && z < 12)
                            return BeyondMath.indicatorRandom(1);

                        return 0;
                    }
                );
                
                return chunk;
            }
        }


        /* Class responsible for chuck loading and unloading, and their cumulative rendering with the neighbour consideration */
        class TerrainGrid {
            
            constructor() {
                this.chunkMap = new Object();
            }

            dropChunk(x, y, z) {
                let cm = this.chunkMap;
                delete cm[[x, y, z]];
            }

            getChunk(x, y, z) {
                let cm = this.chunkMap;
                return cm[[x, y, z]];
            }
            
            uploadChunk(chunk) {
                let cm = this.chunkMap;
                chunk.reset();
                cm[[chunk.cx, chunk.cy, chunk.cz]] = chunk;

                /* Now why do we reset the neighbour chunks? Because the connectivity data might have changed */
                this.getChunk(chunk.cx - 1, chunk.cy, chunk.cz)?.reset();
                this.getChunk(chunk.cx + 1, chunk.cy, chunk.cz)?.reset();
                this.getChunk(chunk.cx, chunk.cy - 1, chunk.cz)?.reset();
                this.getChunk(chunk.cx, chunk.cy + 1, chunk.cz)?.reset();
                this.getChunk(chunk.cx, chunk.cy, chunk.cz - 1)?.reset();
                this.getChunk(chunk.cx, chunk.cy, chunk.cz + 1)?.reset();
            }

            /* TODO: with the TerrainGridManipulator class, this method gets redundant */
            generate(chunkProvider) {
    
                for (let i = -4; i < 4; ++i) {
                    for (let j = -4; j < 4; ++j) {
                        for (let k = -4; k < 4; ++k) {
                            let tc = chunkProvider.obtainChunkFrom(i, j, k);
                            this.uploadChunk(tc);
                        }
                    }
                }
            }
            
            drawToSGB(sgb) {
                
                for (const [key, value] of Object.entries(this.chunkMap)) {
                    
                    let x = value.cx;
                    let y = value.cy;
                    let z = value.cz;
                    
                    value.drawToSGB(
                        sgb
                        , this.getChunk(x - 1, y, z)
                        , this.getChunk(x + 1, y, z)
                        , this.getChunk(x, y + 1, z)
                        , this.getChunk(x, y - 1, z)
                        , this.getChunk(x, y, z + 1)
                        , this.getChunk(x, y, z - 1)                        
                    );
                }
            }

        }

        /* TODO: I need a class that would manually construct TerrainGrid of chunks and update new chunks in it as the new data approaches */
        class TerrainGridManipulator {
            
        };


        /* ========================= ENGINE-DEPENDENT CODE =============================================================== */

        
        const canvas = document.getElementById("renderCanvas"); // Get the canvas element
        const engine = new BABYLON.Engine(canvas, true); // Generate the BABYLON 3D engine

        let myCustomMesh;

        // Add your code here matching the playground format
        const createScene = function () {
    
            const scene = new BABYLON.Scene(engine);
            scene.clearColor = new BABYLON.Color3(0.3, 0.3, 0.6);

            //const camera = new BABYLON.ArcRotateCamera("camera", -Math.PI / 2, Math.PI / 2.5, 15, new BABYLON.Vector3(0, 0, 0));
            const camera = new BABYLON.UniversalCamera("UniversalCamera", new BABYLON.Vector3(0, -5, -10), scene);

            camera.attachControl(canvas, true);

            camera.setTarget(new BABYLON.Vector3(0, 0, 0));
            
            const light = new BABYLON.HemisphericLight("light", new BABYLON.Vector3(1, 1, 0));

            //-------------------------------------------------------------------------------------

            const groundMat2 = new BABYLON.StandardMaterial("groundMat");
            groundMat2.diffuseColor = new BABYLON.Color3(0, 1, 0);

            var img = new Image(512, 512);
            img.src = 'images/trava.png';
            
            const boxMat2 = new BABYLON.StandardMaterial("boxMat");
            //boxMat2.diffuseTexture = new BABYLON.Texture("https://www.babylonjs-playground.com/textures/floor.png");
            boxMat2.diffuseTexture = new BABYLON.Texture("https://i.postimg.cc/3w7Ld88p/trava.png");

            //--------------------------------------------------------------------------------------
            
            var customMesh = new BABYLON.Mesh("custom", scene);

            myCustomMesh = customMesh;
            
            let test_sgb = new SquareGridBuilder();

            let terrain = new TerrainGrid();
            let chunkProvider = new TerrainChunkProvider();

            terrain.generate(chunkProvider);
            terrain.drawToSGB(test_sgb);

            var vertexData = new BABYLON.VertexData();
            
            vertexData.positions = test_sgb.positions;
            vertexData.indices = test_sgb.indices;
            vertexData.normals = test_sgb.normals;
            vertexData.uvs = test_sgb.uvs;

            vertexData.applyToMesh(customMesh);

            customMesh.material = boxMat2;

            //-------------------------------------------------------------------------------------

            return scene;
        };

        const scene = createScene(); //Call the createScene function

        // Register a render loop to repeatedly render the scene
        engine.runRenderLoop(function () {

            scene.render();
        });

        // Watch for browser/canvas resize events
        window.addEventListener("resize", function () {
                engine.resize();
        });
    </script>

   </body>

</html>
